import { arrayify } from './.bytes';
import { type Operand, type Ram, type State } from './state';
import type { Expr, IReverts, IEvents, IStore, Inst } from './ast';
/**
 * Represents an opcode found in the bytecode augmented with
 * offset and operand information as defined by the EVM.
 *
 * It can be either a unary opcode, _which does not take any operand data_,
 * or either a `PUSHn` mnemonic augmented with its push `data`.
 * That is, all but `PUSHn` `n >= 1` opcodes are unary opcodes.
 *
 * `PUSHn` `n >= 1` opcodes takes an `n`-byte argument from the bytecode.
 * Note that `PUSH0`[^1] does not take any data argument from the bytecode (just pushes `0` onto the `Stack`).
 * Thus it can be considered as an unary opcode.
 *
 * [^1]: https://eips.ethereum.org/EIPS/eip-3855
 */
export declare class Opcode<M extends string = string> {
    /**
     * This is the offset in the bytecode where this `Opcode` was found.
     * Both jump instructions, _i.e._, `JUMP` and `JUMPI`,
     * expects a stack operand referencing this `offset` in the bytecode.
     */
    /**
     * The Program Counter of this `Opcode`.
     * The index in the `Opcode[]` where this `Opcode` is inserted.
     */
    readonly pc: number;
    /**
     * Any byte number, _i.e._, between 0 and 255 representing the opcode byte.
     * The `opcode` may not be a valid opcode.
     */
    readonly opcode: number;
    /**
     * Represents a valid opcode.
     *
     * In https://www.evm.codes/ you can find an overview of each EVM opcode.
     *
     * If the `opcode` given is not a valid opcode,
     * you can provide `INVALID` as `mnemonic`.
     *
     * A `PUSHn` opcode only permits a `PUSHn` opcode.
     */
    readonly mnemonic: M;
    /**
     * A `Unary` opcode does not include any `data`. For these opcodes `data` is `null`.
     *
     * If this `Opcode` is a `PUSHn` instruction or contains any operand data,
     * then it contains the data attached to this instruction.
     */
    readonly data: null | Uint8Array;
    constructor(
    /**
     * This is the offset in the bytecode where this `Opcode` was found.
     * Both jump instructions, _i.e._, `JUMP` and `JUMPI`,
     * expects a stack operand referencing this `offset` in the bytecode.
     */
    /**
     * The Program Counter of this `Opcode`.
     * The index in the `Opcode[]` where this `Opcode` is inserted.
     */
    pc: number, 
    /**
     * Any byte number, _i.e._, between 0 and 255 representing the opcode byte.
     * The `opcode` may not be a valid opcode.
     */
    opcode: number, 
    /**
     * Represents a valid opcode.
     *
     * In https://www.evm.codes/ you can find an overview of each EVM opcode.
     *
     * If the `opcode` given is not a valid opcode,
     * you can provide `INVALID` as `mnemonic`.
     *
     * A `PUSHn` opcode only permits a `PUSHn` opcode.
     */
    mnemonic: M, 
    /**
     * A `Unary` opcode does not include any `data`. For these opcodes `data` is `null`.
     *
     * If this `Opcode` is a `PUSHn` instruction or contains any operand data,
     * then it contains the data attached to this instruction.
     */
    data?: null | Uint8Array);
    /**
     * Where the next opcode should be located at.
     */
    get nextpc(): number;
    /**
     * Returns the hexadecimal representation of `this.data`.
     */
    hexData(): string | undefined;
    /**
     * Returns a `string` representation of `this` `Opcode`.
     * Usually used for debugging purposes.
     *
     * @param includeDataAsNumeric whether to include `data` as numeric.
     * @returns the `string` representation of `this` `Opcode`.
     */
    format(includeDataAsNumeric?: boolean): string;
}
/**
 *
 */
export declare class Members {
    readonly events: IEvents;
    readonly variables: IStore['variables'];
    readonly mappings: IStore['mappings'];
    /**
     * Store selectors', _i.e._, public and external `function`s program counter entry.
     */
    readonly functionBranches: Map<string, {
        pc: number;
        state: State<Inst, Expr>;
    }>;
    /**
     *
     */
    readonly reverts: IReverts;
    getError(selector: string): IReverts[string];
}
/**
 * This module is used to `decode` bytecode into `Opcode`.
 *
 * Maps numeric opcodes (byte between `0` and `255`) to decode configuration and string mnemonic.
 * That is, for the given `opcode`,
 * `size` indicates the size of the `opcode`'s operand to consume from bytecode in bytes.
 * `halts` indicates where the step associated with this `opcode` should `halt` the EVM `State`.
 * `mnemonic` indicates the step the `EVM` should execute.
 */
export declare class Undef<M extends string> extends Members {
    [opcode: number]: [size: number, halts: boolean, mnemonic: M];
    constructor();
    UNDEF: (state: State<Inst, Expr>, op: Opcode) => void;
    /**
     * Retrieves the `mnemonic` of the steps which `halts` the EVM `State`.
     */
    haltingSteps(): M[];
    /**
     * Retrieves the opcodes by mnemonic.
     */
    opcodes(): {
        readonly [m in M]: number;
    };
    /**
     * Decodes the input `bytecode` into `Opcode`s.
     * `bytecode` may be a hexadecimal string,
     * which may or may not begin with the hex prefix `0x`.
     *
     * ### Example
     *
     * ```typescript
     * const opcodes = [...this.decode('0x6003600501')];
     * ```
     *
     * @param bytecode hexadecimal string or array of numbers containing the bytecode to decode.
     * @param begin the byte position where to start decoding the `input` bytecode,
     * defaults to `0` if not provided.
     * @returns a generator of the decoded `Opcode`s found in `bytecode`.
     */
    decode(bytecode: Parameters<typeof arrayify>[0], begin?: number): Generator<Opcode<M>, void, unknown>;
}
/**
 * The step transition function.
 *
 * The `EVM` executes a `StepFn` transition for each `opcode` found in the `evm.bytecode`.
 * It should change the `state` accordingly to the `opcode` found.
 */
export type StepFn = (state: State<Inst, Expr>, opcode: Opcode, evm: {
    bytecode: Uint8Array;
}) => void;
export declare const JUMPDEST = 91;
/**
 * https://eips.ethereum.org/EIPS/eip-3198
 *
 * Keep track of https://eips.ethereum.org/EIPS/eip-4200
 */
export declare const London: new () => Undef<"ADDMOD" | "MULMOD" | "SIGNEXTEND" | "EQ" | "ISZERO" | "NOT" | "BYTE" | "COINBASE" | "TIMESTAMP" | "NUMBER" | "DIFFICULTY" | "GASLIMIT" | "CALLER" | "CALLDATASIZE" | "ORIGIN" | "GASPRICE" | "ADDRESS" | "CODESIZE" | "RETURNDATASIZE" | "GAS" | "CALLVALUE" | "CALLDATALOAD" | "CALLDATACOPY" | "CODECOPY" | "EXTCODECOPY" | "RETURNDATACOPY" | "SLOAD" | "SSTORE" | "POP" | "PUSH2" | "PUSH1" | "PUSH16" | "PUSH3" | "PUSH8" | "PUSH9" | "PUSH11" | "PUSH20" | "PUSH21" | "PUSH25" | "PUSH26" | "PUSH5" | "PUSH32" | "PUSH4" | "PUSH6" | "PUSH7" | "PUSH10" | "PUSH12" | "PUSH13" | "PUSH14" | "PUSH15" | "PUSH24" | "PUSH17" | "PUSH18" | "PUSH19" | "PUSH22" | "PUSH23" | "PUSH27" | "PUSH28" | "PUSH29" | "PUSH30" | "PUSH31" | "DUP2" | "DUP1" | "DUP16" | "DUP3" | "DUP8" | "DUP9" | "DUP11" | "DUP5" | "DUP4" | "DUP6" | "DUP7" | "DUP10" | "DUP12" | "DUP13" | "DUP14" | "DUP15" | "SWAP2" | "SWAP1" | "SWAP16" | "SWAP3" | "SWAP8" | "SWAP9" | "SWAP11" | "SWAP5" | "SWAP4" | "SWAP6" | "SWAP7" | "SWAP10" | "SWAP12" | "SWAP13" | "SWAP14" | "SWAP15" | "ADD" | "MUL" | "SUB" | "DIV" | "SDIV" | "MOD" | "SMOD" | "EXP" | "LT" | "GT" | "SLT" | "SGT" | "AND" | "OR" | "XOR" | "PC" | "BALANCE" | "EXTCODESIZE" | "EXTCODEHASH" | "BLOCKHASH" | "MLOAD" | "MSTORE" | "MSTORE8" | "MSIZE" | "SHA3" | "STOP" | "CREATE" | "CALL" | "CALLCODE" | "RETURN" | "DELEGATECALL" | "STATICCALL" | "REVERT" | "SELFDESTRUCT" | "INVALID" | "LOG0" | "LOG2" | "LOG1" | "LOG3" | "LOG4" | "JUMPDEST" | "JUMP" | "JUMPI" | "SHL" | "SHR" | "SAR" | "CREATE2" | "CHAINID" | "SELFBALANCE" | "BASEFEE"> & {
    readonly BASEFEE: ({ stack }: Operand<Expr>) => void;
    readonly CHAINID: ({ stack }: Operand<Expr>) => void;
    readonly SELFBALANCE: ({ stack }: Operand<Expr>) => void;
    readonly CREATE2: ({ stack }: State<Inst, Expr>) => void;
    readonly SHL: ({ stack }: Operand<Expr>) => void;
    readonly SHR: ({ stack }: Operand<Expr>) => void;
    readonly SAR: ({ stack }: Operand<Expr>) => void;
    readonly EQ: ({ stack }: Operand<Expr>) => void;
    readonly ISZERO: ({ stack }: Operand<Expr>) => void;
    readonly JUMPDEST: (_state: State<Inst, Expr>) => void;
    readonly JUMP: (state: State<Inst, Expr>, opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly JUMPI: (this: Members, state: State<Inst, Expr>, opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly SLOAD: (this: IStore, { stack }: State<Inst, Expr>) => void;
    readonly SSTORE: (this: IStore, { stack, stmts }: State<Inst, Expr>) => void;
    readonly LOG0: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG2: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG1: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG3: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG4: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MSIZE: ({ stack }: Operand<Expr>) => void;
    readonly SHA3: (state: Ram<Expr>) => void;
    readonly STOP: (state: State<Inst, Expr>) => void;
    readonly CREATE: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly CALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly CALLCODE: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly RETURN: (state: State<Inst, Expr>) => void;
    readonly DELEGATECALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly STATICCALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly REVERT: (this: Members, state: State<Inst, Expr>) => void;
    readonly SELFDESTRUCT: (state: State<Inst, Expr>) => void;
    readonly INVALID: (state: State<Inst, Expr>, op: Opcode<string>) => void;
    readonly MSTORE: ({ stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MSTORE8: ({ stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MLOAD: ({ stack, memory }: Ram<Expr>) => void;
    readonly CALLDATACOPY: (state: State<Inst, Expr>) => void;
    readonly CODECOPY: ({ stack, memory }: State<Inst, Expr>, _opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly EXTCODECOPY: (state: State<Inst, Expr>) => void;
    readonly RETURNDATACOPY: (state: State<Inst, Expr>) => void;
    readonly BALANCE: ({ stack }: State<Inst, Expr>) => void;
    readonly EXTCODESIZE: ({ stack }: State<Inst, Expr>) => void;
    readonly EXTCODEHASH: ({ stack }: State<Inst, Expr>) => void;
    readonly BLOCKHASH: ({ stack }: State<Inst, Expr>) => void;
    readonly PC: ({ stack }: State<Inst, Expr>, op: Opcode<string>) => void;
    readonly COINBASE: ({ stack }: Operand<Expr>) => void;
    readonly TIMESTAMP: ({ stack }: Operand<Expr>) => void;
    readonly NUMBER: ({ stack }: Operand<Expr>) => void;
    readonly DIFFICULTY: ({ stack }: Operand<Expr>) => void;
    readonly GASLIMIT: ({ stack }: Operand<Expr>) => void;
    readonly CALLER: ({ stack }: Operand<Expr>) => void;
    readonly CALLDATASIZE: ({ stack }: Operand<Expr>) => void;
    readonly ORIGIN: ({ stack }: Operand<Expr>) => void;
    readonly GASPRICE: ({ stack }: Operand<Expr>) => void;
    readonly ADDRESS: ({ stack }: Operand<Expr>) => void;
    readonly CODESIZE: ({ stack }: Operand<Expr>) => void;
    readonly RETURNDATASIZE: ({ stack }: Operand<Expr>) => void;
    readonly GAS: ({ stack }: Operand<Expr>) => void;
    readonly CALLVALUE: ({ stack }: Operand<Expr>) => void;
    readonly CALLDATALOAD: ({ stack }: Operand<Expr>) => void;
    readonly ADDMOD: ({ stack }: Operand<Expr>) => void;
    readonly MULMOD: ({ stack }: Operand<Expr>) => void;
    readonly SIGNEXTEND: ({ stack }: Operand<Expr>) => void;
    readonly NOT: ({ stack }: Operand<Expr>) => void;
    readonly BYTE: ({ stack }: Operand<Expr>) => void;
    readonly ADD: ({ stack }: Operand<Expr>) => void;
    readonly MUL: ({ stack }: Operand<Expr>) => void;
    readonly SUB: ({ stack }: Operand<Expr>) => void;
    readonly DIV: ({ stack }: Operand<Expr>) => void;
    readonly SDIV: ({ stack }: Operand<Expr>) => void;
    readonly MOD: ({ stack }: Operand<Expr>) => void;
    readonly SMOD: ({ stack }: Operand<Expr>) => void;
    readonly EXP: ({ stack }: Operand<Expr>) => void;
    readonly LT: ({ stack }: Operand<Expr>) => void;
    readonly GT: ({ stack }: Operand<Expr>) => void;
    readonly SLT: ({ stack }: Operand<Expr>) => void;
    readonly SGT: ({ stack }: Operand<Expr>) => void;
    readonly AND: ({ stack }: Operand<Expr>) => void;
    readonly OR: ({ stack }: Operand<Expr>) => void;
    readonly XOR: ({ stack }: Operand<Expr>) => void;
    readonly SWAP2: ({ stack }: Operand<Expr>) => void;
    readonly SWAP1: ({ stack }: Operand<Expr>) => void;
    readonly SWAP16: ({ stack }: Operand<Expr>) => void;
    readonly SWAP3: ({ stack }: Operand<Expr>) => void;
    readonly SWAP8: ({ stack }: Operand<Expr>) => void;
    readonly SWAP9: ({ stack }: Operand<Expr>) => void;
    readonly SWAP11: ({ stack }: Operand<Expr>) => void;
    readonly SWAP5: ({ stack }: Operand<Expr>) => void;
    readonly SWAP4: ({ stack }: Operand<Expr>) => void;
    readonly SWAP6: ({ stack }: Operand<Expr>) => void;
    readonly SWAP7: ({ stack }: Operand<Expr>) => void;
    readonly SWAP10: ({ stack }: Operand<Expr>) => void;
    readonly SWAP12: ({ stack }: Operand<Expr>) => void;
    readonly SWAP13: ({ stack }: Operand<Expr>) => void;
    readonly SWAP14: ({ stack }: Operand<Expr>) => void;
    readonly SWAP15: ({ stack }: Operand<Expr>) => void;
    readonly DUP2: (state: State<Inst, Expr>) => void;
    readonly DUP1: (state: State<Inst, Expr>) => void;
    readonly DUP16: (state: State<Inst, Expr>) => void;
    readonly DUP3: (state: State<Inst, Expr>) => void;
    readonly DUP8: (state: State<Inst, Expr>) => void;
    readonly DUP9: (state: State<Inst, Expr>) => void;
    readonly DUP11: (state: State<Inst, Expr>) => void;
    readonly DUP5: (state: State<Inst, Expr>) => void;
    readonly DUP4: (state: State<Inst, Expr>) => void;
    readonly DUP6: (state: State<Inst, Expr>) => void;
    readonly DUP7: (state: State<Inst, Expr>) => void;
    readonly DUP10: (state: State<Inst, Expr>) => void;
    readonly DUP12: (state: State<Inst, Expr>) => void;
    readonly DUP13: (state: State<Inst, Expr>) => void;
    readonly DUP14: (state: State<Inst, Expr>) => void;
    readonly DUP15: (state: State<Inst, Expr>) => void;
    readonly PUSH2: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH1: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH16: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH3: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH8: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH9: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH11: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH20: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH21: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH25: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH26: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH5: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH32: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH4: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH6: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH7: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH10: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH12: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH13: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH14: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH15: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH24: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH17: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH18: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH19: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH22: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH23: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH27: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH28: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH29: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH30: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH31: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly POP: ({ stack }: Operand<Expr>) => Expr;
};
/**
 * Defines the `Paris` hardfork.
 * It includes the `PREVRANDAO` instruction.
 *
 * Solidity `0.8.18` includes _Support for Paris Hardfork_,
 * which introduces the global `block.prevrandao` built-in in Solidity and `prevrandao()`
 * instruction in inline assembly and Yul for EVM versions >= Paris.
 *
 * @see https://ethereum.github.io/execution-specs/diffs/gray_glacier_paris.html
 * @see https://eips.ethereum.org/EIPS/eip-4399
 * @see https://soliditylang.org/blog/2023/02/01/solidity-0.8.18-release-announcement
 */
export declare const Paris: new () => Undef<"ADDMOD" | "MULMOD" | "SIGNEXTEND" | "EQ" | "ISZERO" | "NOT" | "BYTE" | "COINBASE" | "TIMESTAMP" | "NUMBER" | "DIFFICULTY" | "GASLIMIT" | "CALLER" | "CALLDATASIZE" | "ORIGIN" | "GASPRICE" | "ADDRESS" | "CODESIZE" | "RETURNDATASIZE" | "GAS" | "CALLVALUE" | "CALLDATALOAD" | "CALLDATACOPY" | "CODECOPY" | "EXTCODECOPY" | "RETURNDATACOPY" | "SLOAD" | "SSTORE" | "POP" | "PUSH2" | "PUSH1" | "PUSH16" | "PUSH3" | "PUSH8" | "PUSH9" | "PUSH11" | "PUSH20" | "PUSH21" | "PUSH25" | "PUSH26" | "PUSH5" | "PUSH32" | "PUSH4" | "PUSH6" | "PUSH7" | "PUSH10" | "PUSH12" | "PUSH13" | "PUSH14" | "PUSH15" | "PUSH24" | "PUSH17" | "PUSH18" | "PUSH19" | "PUSH22" | "PUSH23" | "PUSH27" | "PUSH28" | "PUSH29" | "PUSH30" | "PUSH31" | "DUP2" | "DUP1" | "DUP16" | "DUP3" | "DUP8" | "DUP9" | "DUP11" | "DUP5" | "DUP4" | "DUP6" | "DUP7" | "DUP10" | "DUP12" | "DUP13" | "DUP14" | "DUP15" | "SWAP2" | "SWAP1" | "SWAP16" | "SWAP3" | "SWAP8" | "SWAP9" | "SWAP11" | "SWAP5" | "SWAP4" | "SWAP6" | "SWAP7" | "SWAP10" | "SWAP12" | "SWAP13" | "SWAP14" | "SWAP15" | "ADD" | "MUL" | "SUB" | "DIV" | "SDIV" | "MOD" | "SMOD" | "EXP" | "LT" | "GT" | "SLT" | "SGT" | "AND" | "OR" | "XOR" | "PC" | "BALANCE" | "EXTCODESIZE" | "EXTCODEHASH" | "BLOCKHASH" | "MLOAD" | "MSTORE" | "MSTORE8" | "MSIZE" | "SHA3" | "STOP" | "CREATE" | "CALL" | "CALLCODE" | "RETURN" | "DELEGATECALL" | "STATICCALL" | "REVERT" | "SELFDESTRUCT" | "INVALID" | "LOG0" | "LOG2" | "LOG1" | "LOG3" | "LOG4" | "JUMPDEST" | "JUMP" | "JUMPI" | "SHL" | "SHR" | "SAR" | "CREATE2" | "CHAINID" | "SELFBALANCE" | "PREVRANDAO" | "BASEFEE"> & {
    readonly PREVRANDAO: ({ stack }: Operand<Expr>) => void;
    readonly BASEFEE: ({ stack }: Operand<Expr>) => void;
    readonly CHAINID: ({ stack }: Operand<Expr>) => void;
    readonly SELFBALANCE: ({ stack }: Operand<Expr>) => void;
    readonly CREATE2: ({ stack }: State<Inst, Expr>) => void;
    readonly SHL: ({ stack }: Operand<Expr>) => void;
    readonly SHR: ({ stack }: Operand<Expr>) => void;
    readonly SAR: ({ stack }: Operand<Expr>) => void;
    readonly EQ: ({ stack }: Operand<Expr>) => void;
    readonly ISZERO: ({ stack }: Operand<Expr>) => void;
    readonly JUMPDEST: (_state: State<Inst, Expr>) => void;
    readonly JUMP: (state: State<Inst, Expr>, opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly JUMPI: (this: Members, state: State<Inst, Expr>, opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly SLOAD: (this: IStore, { stack }: State<Inst, Expr>) => void;
    readonly SSTORE: (this: IStore, { stack, stmts }: State<Inst, Expr>) => void;
    readonly LOG0: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG2: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG1: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG3: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG4: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MSIZE: ({ stack }: Operand<Expr>) => void;
    readonly SHA3: (state: Ram<Expr>) => void;
    readonly STOP: (state: State<Inst, Expr>) => void;
    readonly CREATE: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly CALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly CALLCODE: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly RETURN: (state: State<Inst, Expr>) => void;
    readonly DELEGATECALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly STATICCALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly REVERT: (this: Members, state: State<Inst, Expr>) => void;
    readonly SELFDESTRUCT: (state: State<Inst, Expr>) => void;
    readonly INVALID: (state: State<Inst, Expr>, op: Opcode<string>) => void;
    readonly MSTORE: ({ stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MSTORE8: ({ stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MLOAD: ({ stack, memory }: Ram<Expr>) => void;
    readonly CALLDATACOPY: (state: State<Inst, Expr>) => void;
    readonly CODECOPY: ({ stack, memory }: State<Inst, Expr>, _opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly EXTCODECOPY: (state: State<Inst, Expr>) => void;
    readonly RETURNDATACOPY: (state: State<Inst, Expr>) => void;
    readonly BALANCE: ({ stack }: State<Inst, Expr>) => void;
    readonly EXTCODESIZE: ({ stack }: State<Inst, Expr>) => void;
    readonly EXTCODEHASH: ({ stack }: State<Inst, Expr>) => void;
    readonly BLOCKHASH: ({ stack }: State<Inst, Expr>) => void;
    readonly PC: ({ stack }: State<Inst, Expr>, op: Opcode<string>) => void;
    readonly COINBASE: ({ stack }: Operand<Expr>) => void;
    readonly TIMESTAMP: ({ stack }: Operand<Expr>) => void;
    readonly NUMBER: ({ stack }: Operand<Expr>) => void;
    readonly DIFFICULTY: ({ stack }: Operand<Expr>) => void;
    readonly GASLIMIT: ({ stack }: Operand<Expr>) => void;
    readonly CALLER: ({ stack }: Operand<Expr>) => void;
    readonly CALLDATASIZE: ({ stack }: Operand<Expr>) => void;
    readonly ORIGIN: ({ stack }: Operand<Expr>) => void;
    readonly GASPRICE: ({ stack }: Operand<Expr>) => void;
    readonly ADDRESS: ({ stack }: Operand<Expr>) => void;
    readonly CODESIZE: ({ stack }: Operand<Expr>) => void;
    readonly RETURNDATASIZE: ({ stack }: Operand<Expr>) => void;
    readonly GAS: ({ stack }: Operand<Expr>) => void;
    readonly CALLVALUE: ({ stack }: Operand<Expr>) => void;
    readonly CALLDATALOAD: ({ stack }: Operand<Expr>) => void;
    readonly ADDMOD: ({ stack }: Operand<Expr>) => void;
    readonly MULMOD: ({ stack }: Operand<Expr>) => void;
    readonly SIGNEXTEND: ({ stack }: Operand<Expr>) => void;
    readonly NOT: ({ stack }: Operand<Expr>) => void;
    readonly BYTE: ({ stack }: Operand<Expr>) => void;
    readonly ADD: ({ stack }: Operand<Expr>) => void;
    readonly MUL: ({ stack }: Operand<Expr>) => void;
    readonly SUB: ({ stack }: Operand<Expr>) => void;
    readonly DIV: ({ stack }: Operand<Expr>) => void;
    readonly SDIV: ({ stack }: Operand<Expr>) => void;
    readonly MOD: ({ stack }: Operand<Expr>) => void;
    readonly SMOD: ({ stack }: Operand<Expr>) => void;
    readonly EXP: ({ stack }: Operand<Expr>) => void;
    readonly LT: ({ stack }: Operand<Expr>) => void;
    readonly GT: ({ stack }: Operand<Expr>) => void;
    readonly SLT: ({ stack }: Operand<Expr>) => void;
    readonly SGT: ({ stack }: Operand<Expr>) => void;
    readonly AND: ({ stack }: Operand<Expr>) => void;
    readonly OR: ({ stack }: Operand<Expr>) => void;
    readonly XOR: ({ stack }: Operand<Expr>) => void;
    readonly SWAP2: ({ stack }: Operand<Expr>) => void;
    readonly SWAP1: ({ stack }: Operand<Expr>) => void;
    readonly SWAP16: ({ stack }: Operand<Expr>) => void;
    readonly SWAP3: ({ stack }: Operand<Expr>) => void;
    readonly SWAP8: ({ stack }: Operand<Expr>) => void;
    readonly SWAP9: ({ stack }: Operand<Expr>) => void;
    readonly SWAP11: ({ stack }: Operand<Expr>) => void;
    readonly SWAP5: ({ stack }: Operand<Expr>) => void;
    readonly SWAP4: ({ stack }: Operand<Expr>) => void;
    readonly SWAP6: ({ stack }: Operand<Expr>) => void;
    readonly SWAP7: ({ stack }: Operand<Expr>) => void;
    readonly SWAP10: ({ stack }: Operand<Expr>) => void;
    readonly SWAP12: ({ stack }: Operand<Expr>) => void;
    readonly SWAP13: ({ stack }: Operand<Expr>) => void;
    readonly SWAP14: ({ stack }: Operand<Expr>) => void;
    readonly SWAP15: ({ stack }: Operand<Expr>) => void;
    readonly DUP2: (state: State<Inst, Expr>) => void;
    readonly DUP1: (state: State<Inst, Expr>) => void;
    readonly DUP16: (state: State<Inst, Expr>) => void;
    readonly DUP3: (state: State<Inst, Expr>) => void;
    readonly DUP8: (state: State<Inst, Expr>) => void;
    readonly DUP9: (state: State<Inst, Expr>) => void;
    readonly DUP11: (state: State<Inst, Expr>) => void;
    readonly DUP5: (state: State<Inst, Expr>) => void;
    readonly DUP4: (state: State<Inst, Expr>) => void;
    readonly DUP6: (state: State<Inst, Expr>) => void;
    readonly DUP7: (state: State<Inst, Expr>) => void;
    readonly DUP10: (state: State<Inst, Expr>) => void;
    readonly DUP12: (state: State<Inst, Expr>) => void;
    readonly DUP13: (state: State<Inst, Expr>) => void;
    readonly DUP14: (state: State<Inst, Expr>) => void;
    readonly DUP15: (state: State<Inst, Expr>) => void;
    readonly PUSH2: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH1: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH16: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH3: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH8: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH9: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH11: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH20: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH21: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH25: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH26: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH5: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH32: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH4: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH6: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH7: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH10: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH12: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH13: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH14: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH15: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH24: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH17: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH18: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH19: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH22: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH23: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH27: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH28: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH29: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH30: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH31: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly POP: ({ stack }: Operand<Expr>) => Expr;
};
/**
 * Defines the `Shanghai` hardfork.
 * It includes the `PUSH0` instruction.
 *
 * Solidity `0.8.20` uses `push0` for placing `0` on the Stack.
 * This decreases the deployment and runtime costs.
 *
 * Keep track of https://eips.ethereum.org/EIPS/eip-6780
 *
 * @see https://ethereum.github.io/execution-specs/diffs/paris_shanghai.html
 * @see https://eips.ethereum.org/EIPS/eip-3855
 * @see https://soliditylang.org/blog/2023/05/10/solidity-0.8.20-release-announcement/
 */
export declare const Shanghai: new () => Undef<"ADDMOD" | "MULMOD" | "SIGNEXTEND" | "EQ" | "ISZERO" | "NOT" | "BYTE" | "COINBASE" | "TIMESTAMP" | "NUMBER" | "DIFFICULTY" | "GASLIMIT" | "CALLER" | "CALLDATASIZE" | "ORIGIN" | "GASPRICE" | "ADDRESS" | "CODESIZE" | "RETURNDATASIZE" | "GAS" | "CALLVALUE" | "CALLDATALOAD" | "CALLDATACOPY" | "CODECOPY" | "EXTCODECOPY" | "RETURNDATACOPY" | "SLOAD" | "SSTORE" | "POP" | "PUSH2" | "PUSH1" | "PUSH16" | "PUSH3" | "PUSH8" | "PUSH9" | "PUSH11" | "PUSH20" | "PUSH21" | "PUSH25" | "PUSH26" | "PUSH5" | "PUSH32" | "PUSH4" | "PUSH6" | "PUSH7" | "PUSH10" | "PUSH12" | "PUSH13" | "PUSH14" | "PUSH15" | "PUSH24" | "PUSH17" | "PUSH18" | "PUSH19" | "PUSH22" | "PUSH23" | "PUSH27" | "PUSH28" | "PUSH29" | "PUSH30" | "PUSH31" | "DUP2" | "DUP1" | "DUP16" | "DUP3" | "DUP8" | "DUP9" | "DUP11" | "DUP5" | "DUP4" | "DUP6" | "DUP7" | "DUP10" | "DUP12" | "DUP13" | "DUP14" | "DUP15" | "SWAP2" | "SWAP1" | "SWAP16" | "SWAP3" | "SWAP8" | "SWAP9" | "SWAP11" | "SWAP5" | "SWAP4" | "SWAP6" | "SWAP7" | "SWAP10" | "SWAP12" | "SWAP13" | "SWAP14" | "SWAP15" | "ADD" | "MUL" | "SUB" | "DIV" | "SDIV" | "MOD" | "SMOD" | "EXP" | "LT" | "GT" | "SLT" | "SGT" | "AND" | "OR" | "XOR" | "PC" | "BALANCE" | "EXTCODESIZE" | "EXTCODEHASH" | "BLOCKHASH" | "MLOAD" | "MSTORE" | "MSTORE8" | "MSIZE" | "SHA3" | "STOP" | "CREATE" | "CALL" | "CALLCODE" | "RETURN" | "DELEGATECALL" | "STATICCALL" | "REVERT" | "SELFDESTRUCT" | "INVALID" | "LOG0" | "LOG2" | "LOG1" | "LOG3" | "LOG4" | "JUMPDEST" | "JUMP" | "JUMPI" | "SHL" | "SHR" | "SAR" | "CREATE2" | "CHAINID" | "SELFBALANCE" | "PREVRANDAO" | "BASEFEE" | "PUSH0"> & {
    readonly SUB: ({ stack }: Operand<Expr>) => void;
    readonly ISZERO: ({ stack, memory }: Ram<Expr>) => void;
    readonly XOR: ({ stack, memory }: Ram<Expr>) => void;
    readonly PUSH0: (state: State<Inst, Expr>) => void;
    readonly PREVRANDAO: ({ stack }: Operand<Expr>) => void;
    readonly BASEFEE: ({ stack }: Operand<Expr>) => void;
    readonly CHAINID: ({ stack }: Operand<Expr>) => void;
    readonly SELFBALANCE: ({ stack }: Operand<Expr>) => void;
    readonly CREATE2: ({ stack }: State<Inst, Expr>) => void;
    readonly SHL: ({ stack }: Operand<Expr>) => void;
    readonly SHR: ({ stack }: Operand<Expr>) => void;
    readonly SAR: ({ stack }: Operand<Expr>) => void;
    readonly EQ: ({ stack }: Operand<Expr>) => void;
    readonly JUMPDEST: (_state: State<Inst, Expr>) => void;
    readonly JUMP: (state: State<Inst, Expr>, opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly JUMPI: (this: Members, state: State<Inst, Expr>, opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly SLOAD: (this: IStore, { stack }: State<Inst, Expr>) => void;
    readonly SSTORE: (this: IStore, { stack, stmts }: State<Inst, Expr>) => void;
    readonly LOG0: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG2: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG1: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG3: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly LOG4: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MSIZE: ({ stack }: Operand<Expr>) => void;
    readonly SHA3: (state: Ram<Expr>) => void;
    readonly STOP: (state: State<Inst, Expr>) => void;
    readonly CREATE: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly CALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly CALLCODE: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly RETURN: (state: State<Inst, Expr>) => void;
    readonly DELEGATECALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly STATICCALL: ({ stack, memory }: State<Inst, Expr>) => void;
    readonly REVERT: (this: Members, state: State<Inst, Expr>) => void;
    readonly SELFDESTRUCT: (state: State<Inst, Expr>) => void;
    readonly INVALID: (state: State<Inst, Expr>, op: Opcode<string>) => void;
    readonly MSTORE: ({ stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MSTORE8: ({ stack, memory, stmts }: State<Inst, Expr>) => void;
    readonly MLOAD: ({ stack, memory }: Ram<Expr>) => void;
    readonly CALLDATACOPY: (state: State<Inst, Expr>) => void;
    readonly CODECOPY: ({ stack, memory }: State<Inst, Expr>, _opcode: Opcode<string>, { bytecode }: {
        bytecode: Uint8Array;
    }) => void;
    readonly EXTCODECOPY: (state: State<Inst, Expr>) => void;
    readonly RETURNDATACOPY: (state: State<Inst, Expr>) => void;
    readonly BALANCE: ({ stack }: State<Inst, Expr>) => void;
    readonly EXTCODESIZE: ({ stack }: State<Inst, Expr>) => void;
    readonly EXTCODEHASH: ({ stack }: State<Inst, Expr>) => void;
    readonly BLOCKHASH: ({ stack }: State<Inst, Expr>) => void;
    readonly PC: ({ stack }: State<Inst, Expr>, op: Opcode<string>) => void;
    readonly COINBASE: ({ stack }: Operand<Expr>) => void;
    readonly TIMESTAMP: ({ stack }: Operand<Expr>) => void;
    readonly NUMBER: ({ stack }: Operand<Expr>) => void;
    readonly DIFFICULTY: ({ stack }: Operand<Expr>) => void;
    readonly GASLIMIT: ({ stack }: Operand<Expr>) => void;
    readonly CALLER: ({ stack }: Operand<Expr>) => void;
    readonly CALLDATASIZE: ({ stack }: Operand<Expr>) => void;
    readonly ORIGIN: ({ stack }: Operand<Expr>) => void;
    readonly GASPRICE: ({ stack }: Operand<Expr>) => void;
    readonly ADDRESS: ({ stack }: Operand<Expr>) => void;
    readonly CODESIZE: ({ stack }: Operand<Expr>) => void;
    readonly RETURNDATASIZE: ({ stack }: Operand<Expr>) => void;
    readonly GAS: ({ stack }: Operand<Expr>) => void;
    readonly CALLVALUE: ({ stack }: Operand<Expr>) => void;
    readonly CALLDATALOAD: ({ stack }: Operand<Expr>) => void;
    readonly ADDMOD: ({ stack }: Operand<Expr>) => void;
    readonly MULMOD: ({ stack }: Operand<Expr>) => void;
    readonly SIGNEXTEND: ({ stack }: Operand<Expr>) => void;
    readonly NOT: ({ stack }: Operand<Expr>) => void;
    readonly BYTE: ({ stack }: Operand<Expr>) => void;
    readonly ADD: ({ stack }: Operand<Expr>) => void;
    readonly MUL: ({ stack }: Operand<Expr>) => void;
    readonly DIV: ({ stack }: Operand<Expr>) => void;
    readonly SDIV: ({ stack }: Operand<Expr>) => void;
    readonly MOD: ({ stack }: Operand<Expr>) => void;
    readonly SMOD: ({ stack }: Operand<Expr>) => void;
    readonly EXP: ({ stack }: Operand<Expr>) => void;
    readonly LT: ({ stack }: Operand<Expr>) => void;
    readonly GT: ({ stack }: Operand<Expr>) => void;
    readonly SLT: ({ stack }: Operand<Expr>) => void;
    readonly SGT: ({ stack }: Operand<Expr>) => void;
    readonly AND: ({ stack }: Operand<Expr>) => void;
    readonly OR: ({ stack }: Operand<Expr>) => void;
    readonly SWAP2: ({ stack }: Operand<Expr>) => void;
    readonly SWAP1: ({ stack }: Operand<Expr>) => void;
    readonly SWAP16: ({ stack }: Operand<Expr>) => void;
    readonly SWAP3: ({ stack }: Operand<Expr>) => void;
    readonly SWAP8: ({ stack }: Operand<Expr>) => void;
    readonly SWAP9: ({ stack }: Operand<Expr>) => void;
    readonly SWAP11: ({ stack }: Operand<Expr>) => void;
    readonly SWAP5: ({ stack }: Operand<Expr>) => void;
    readonly SWAP4: ({ stack }: Operand<Expr>) => void;
    readonly SWAP6: ({ stack }: Operand<Expr>) => void;
    readonly SWAP7: ({ stack }: Operand<Expr>) => void;
    readonly SWAP10: ({ stack }: Operand<Expr>) => void;
    readonly SWAP12: ({ stack }: Operand<Expr>) => void;
    readonly SWAP13: ({ stack }: Operand<Expr>) => void;
    readonly SWAP14: ({ stack }: Operand<Expr>) => void;
    readonly SWAP15: ({ stack }: Operand<Expr>) => void;
    readonly DUP2: (state: State<Inst, Expr>) => void;
    readonly DUP1: (state: State<Inst, Expr>) => void;
    readonly DUP16: (state: State<Inst, Expr>) => void;
    readonly DUP3: (state: State<Inst, Expr>) => void;
    readonly DUP8: (state: State<Inst, Expr>) => void;
    readonly DUP9: (state: State<Inst, Expr>) => void;
    readonly DUP11: (state: State<Inst, Expr>) => void;
    readonly DUP5: (state: State<Inst, Expr>) => void;
    readonly DUP4: (state: State<Inst, Expr>) => void;
    readonly DUP6: (state: State<Inst, Expr>) => void;
    readonly DUP7: (state: State<Inst, Expr>) => void;
    readonly DUP10: (state: State<Inst, Expr>) => void;
    readonly DUP12: (state: State<Inst, Expr>) => void;
    readonly DUP13: (state: State<Inst, Expr>) => void;
    readonly DUP14: (state: State<Inst, Expr>) => void;
    readonly DUP15: (state: State<Inst, Expr>) => void;
    readonly PUSH2: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH1: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH16: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH3: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH8: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH9: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH11: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH20: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH21: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH25: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH26: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH5: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH32: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH4: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH6: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH7: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH10: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH12: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH13: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH14: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH15: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH24: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH17: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH18: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH19: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH22: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH23: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH27: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH28: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH29: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH30: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly PUSH31: (state: State<Inst, Expr>, opcode: Opcode) => void;
    readonly POP: ({ stack }: Operand<Expr>) => Expr;
};
