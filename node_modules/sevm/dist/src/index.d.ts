import { type Expr, type Inst, type Stmt } from './ast';
import type { IEvents } from './ast/log';
import { type IStore } from './ast/storage';
import type { IReverts, Revert } from './ast/system';
import { arrayify } from './.bytes';
import { EVM } from './evm';
import { type Metadata } from './metadata';
import { State } from './state';
import { type Members, type Opcode } from './step';
/**
 *
 */
export declare const ERCIds: ("ERC1155" | "ERC1155MetadataURI" | "ERC165" | "ERC173" | "ERC20" | "ERC20Metadata" | "ERC721" | "ERC721Enumerable" | "ERC721Metadata")[];
/**
 *
 */
export declare class Contract {
    /**
     * The `bytecode` used to create this `Contract`.
     */
    readonly bytecode: Uint8Array;
    /**
     * The `metadataHash` part from the `bytecode`.
     * That is, if present, the `bytecode` without its `code`.
     */
    readonly metadata: Metadata | undefined;
    /**
     *
     */
    readonly main: Stmt[];
    readonly events: IEvents;
    readonly variables: IStore['variables'];
    readonly mappings: IStore['mappings'];
    readonly functionBranches: Members['functionBranches'];
    readonly reverts: IReverts;
    /**
     * Symbolic execution `errors` found during interpretation of `this.bytecode`.
     */
    readonly errors: EVM<string>['errors'];
    readonly blocks: EVM<string>['blocks'];
    readonly chunks: EVM<string>['chunks'];
    /**
     * Returns the `opcode`s present in the **reacheable blocks** of `this` Contract's `bytecode`.
     */
    readonly opcodes: () => Opcode<string>[];
    /**
     *
     */
    readonly functions: {
        [selector: string]: PublicFunction;
    };
    readonly payable: boolean;
    /**
     *
     * @param bytecode the bytecode to analyze in hexadecimal format.
     */
    constructor(bytecode: Parameters<typeof arrayify>[0], step?: import("./step").Undef<"ADDMOD" | "MULMOD" | "SIGNEXTEND" | "EQ" | "ISZERO" | "NOT" | "BYTE" | "COINBASE" | "TIMESTAMP" | "NUMBER" | "DIFFICULTY" | "GASLIMIT" | "CALLER" | "CALLDATASIZE" | "ORIGIN" | "GASPRICE" | "ADDRESS" | "CODESIZE" | "RETURNDATASIZE" | "GAS" | "CALLVALUE" | "CALLDATALOAD" | "CALLDATACOPY" | "CODECOPY" | "EXTCODECOPY" | "RETURNDATACOPY" | "SLOAD" | "SSTORE" | "POP" | "PUSH2" | "PUSH1" | "PUSH16" | "PUSH3" | "PUSH8" | "PUSH9" | "PUSH11" | "PUSH20" | "PUSH21" | "PUSH25" | "PUSH26" | "PUSH5" | "PUSH32" | "PUSH4" | "PUSH6" | "PUSH7" | "PUSH10" | "PUSH12" | "PUSH13" | "PUSH14" | "PUSH15" | "PUSH24" | "PUSH17" | "PUSH18" | "PUSH19" | "PUSH22" | "PUSH23" | "PUSH27" | "PUSH28" | "PUSH29" | "PUSH30" | "PUSH31" | "DUP2" | "DUP1" | "DUP16" | "DUP3" | "DUP8" | "DUP9" | "DUP11" | "DUP5" | "DUP4" | "DUP6" | "DUP7" | "DUP10" | "DUP12" | "DUP13" | "DUP14" | "DUP15" | "SWAP2" | "SWAP1" | "SWAP16" | "SWAP3" | "SWAP8" | "SWAP9" | "SWAP11" | "SWAP5" | "SWAP4" | "SWAP6" | "SWAP7" | "SWAP10" | "SWAP12" | "SWAP13" | "SWAP14" | "SWAP15" | "ADD" | "MUL" | "SUB" | "DIV" | "SDIV" | "MOD" | "SMOD" | "EXP" | "LT" | "GT" | "SLT" | "SGT" | "AND" | "OR" | "XOR" | "PC" | "BALANCE" | "EXTCODESIZE" | "EXTCODEHASH" | "BLOCKHASH" | "MLOAD" | "MSTORE" | "MSTORE8" | "MSIZE" | "SHA3" | "STOP" | "CREATE" | "CALL" | "CALLCODE" | "RETURN" | "DELEGATECALL" | "STATICCALL" | "REVERT" | "SELFDESTRUCT" | "INVALID" | "LOG0" | "LOG2" | "LOG1" | "LOG3" | "LOG4" | "JUMPDEST" | "JUMP" | "JUMPI" | "SHL" | "SHR" | "SAR" | "CREATE2" | "CHAINID" | "SELFBALANCE" | "PREVRANDAO" | "BASEFEE" | "PUSH0"> & {
        readonly SUB: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly ISZERO: ({ stack, memory }: import("./state").Ram<Expr>) => void;
        readonly XOR: ({ stack, memory }: import("./state").Ram<Expr>) => void;
        readonly PUSH0: (state: State<Inst, Expr>) => void;
        readonly PREVRANDAO: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly BASEFEE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly CHAINID: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SELFBALANCE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly CREATE2: ({ stack }: State<Inst, Expr>) => void;
        readonly SHL: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SHR: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SAR: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly EQ: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly JUMPDEST: (_state: State<Inst, Expr>) => void;
        readonly JUMP: (state: State<Inst, Expr>, opcode: Opcode<string>, { bytecode }: {
            bytecode: Uint8Array;
        }) => void;
        readonly JUMPI: (this: Members, state: State<Inst, Expr>, opcode: Opcode<string>, { bytecode }: {
            bytecode: Uint8Array;
        }) => void;
        readonly SLOAD: (this: IStore, { stack }: State<Inst, Expr>) => void;
        readonly SSTORE: (this: IStore, { stack, stmts }: State<Inst, Expr>) => void;
        readonly LOG0: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
        readonly LOG2: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
        readonly LOG1: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
        readonly LOG3: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
        readonly LOG4: (this: Members, { stack, memory, stmts }: State<Inst, Expr>) => void;
        readonly MSIZE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SHA3: (state: import("./state").Ram<Expr>) => void;
        readonly STOP: (state: State<Inst, Expr>) => void;
        readonly CREATE: ({ stack, memory }: State<Inst, Expr>) => void;
        readonly CALL: ({ stack, memory }: State<Inst, Expr>) => void;
        readonly CALLCODE: ({ stack, memory }: State<Inst, Expr>) => void;
        readonly RETURN: (state: State<Inst, Expr>) => void;
        readonly DELEGATECALL: ({ stack, memory }: State<Inst, Expr>) => void;
        readonly STATICCALL: ({ stack, memory }: State<Inst, Expr>) => void;
        readonly REVERT: (this: Members, state: State<Inst, Expr>) => void;
        readonly SELFDESTRUCT: (state: State<Inst, Expr>) => void;
        readonly INVALID: (state: State<Inst, Expr>, op: Opcode<string>) => void;
        readonly MSTORE: ({ stack, memory, stmts }: State<Inst, Expr>) => void;
        readonly MSTORE8: ({ stack, memory, stmts }: State<Inst, Expr>) => void;
        readonly MLOAD: ({ stack, memory }: import("./state").Ram<Expr>) => void;
        readonly CALLDATACOPY: (state: State<Inst, Expr>) => void;
        readonly CODECOPY: ({ stack, memory }: State<Inst, Expr>, _opcode: Opcode<string>, { bytecode }: {
            bytecode: Uint8Array;
        }) => void;
        readonly EXTCODECOPY: (state: State<Inst, Expr>) => void;
        readonly RETURNDATACOPY: (state: State<Inst, Expr>) => void;
        readonly BALANCE: ({ stack }: State<Inst, Expr>) => void;
        readonly EXTCODESIZE: ({ stack }: State<Inst, Expr>) => void;
        readonly EXTCODEHASH: ({ stack }: State<Inst, Expr>) => void;
        readonly BLOCKHASH: ({ stack }: State<Inst, Expr>) => void;
        readonly PC: ({ stack }: State<Inst, Expr>, op: Opcode<string>) => void;
        readonly COINBASE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly TIMESTAMP: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly NUMBER: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly DIFFICULTY: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly GASLIMIT: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly CALLER: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly CALLDATASIZE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly ORIGIN: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly GASPRICE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly ADDRESS: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly CODESIZE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly RETURNDATASIZE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly GAS: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly CALLVALUE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly CALLDATALOAD: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly ADDMOD: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly MULMOD: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SIGNEXTEND: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly NOT: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly BYTE: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly ADD: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly MUL: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly DIV: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SDIV: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly MOD: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SMOD: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly EXP: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly LT: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly GT: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SLT: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SGT: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly AND: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly OR: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP2: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP1: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP16: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP3: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP8: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP9: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP11: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP5: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP4: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP6: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP7: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP10: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP12: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP13: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP14: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly SWAP15: ({ stack }: import("./state").Operand<Expr>) => void;
        readonly DUP2: (state: State<Inst, Expr>) => void;
        readonly DUP1: (state: State<Inst, Expr>) => void;
        readonly DUP16: (state: State<Inst, Expr>) => void;
        readonly DUP3: (state: State<Inst, Expr>) => void;
        readonly DUP8: (state: State<Inst, Expr>) => void;
        readonly DUP9: (state: State<Inst, Expr>) => void;
        readonly DUP11: (state: State<Inst, Expr>) => void;
        readonly DUP5: (state: State<Inst, Expr>) => void;
        readonly DUP4: (state: State<Inst, Expr>) => void;
        readonly DUP6: (state: State<Inst, Expr>) => void;
        readonly DUP7: (state: State<Inst, Expr>) => void;
        readonly DUP10: (state: State<Inst, Expr>) => void;
        readonly DUP12: (state: State<Inst, Expr>) => void;
        readonly DUP13: (state: State<Inst, Expr>) => void;
        readonly DUP14: (state: State<Inst, Expr>) => void;
        readonly DUP15: (state: State<Inst, Expr>) => void;
        readonly PUSH2: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH1: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH16: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH3: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH8: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH9: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH11: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH20: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH21: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH25: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH26: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH5: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH32: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH4: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH6: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH7: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH10: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH12: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH13: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH14: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH15: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH24: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH17: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH18: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH19: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH22: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH23: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH27: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH28: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH29: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH30: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly PUSH31: (state: State<Inst, Expr>, opcode: Opcode<string>) => void;
        readonly POP: ({ stack }: import("./state").Operand<Expr>) => Expr;
    }, main?: State<Inst, Expr>);
    reduce(): Contract;
    /**
     *
     * @returns
     */
    getFunctions(): string[];
    /**
     *
     * @returns
     */
    getEvents(): string[];
    /**
     * https://eips.ethereum.org/EIPS/eip-165
     * https://eips.ethereum.org/EIPS/eip-20
     * https://eips.ethereum.org/EIPS/eip-20
     * https://eips.ethereum.org/EIPS/eip-721
     *
     * @param ercid
     * @returns
     */
    isERC(ercid: (typeof ERCIds)[number], checkEvents?: boolean): boolean;
}
export declare function isRevertBlock(falseBlock: Stmt[]): falseBlock is [...Inst[], Revert];
export declare class PublicFunction {
    readonly contract: Contract;
    readonly stmts: Stmt[];
    readonly selector: string;
    /**
     *
     */
    private _label;
    readonly payable: boolean;
    readonly visibility: string;
    readonly constant: boolean;
    readonly returns: string[];
    constructor(contract: Contract, stmts: Stmt[], selector: string, payable?: boolean);
    get label(): string | undefined;
    set label(value: string | undefined);
    private isGetter;
    private isMappingGetter;
    private static findReturns;
    private static patchCallDataLoad;
}
export declare function build(state: State<Inst, Expr>): Stmt[];
export declare function reduce0(stmts: Inst[]): Stmt[];
export * from './abi';
export * from './evm';
export * from './metadata';
export * from './sol';
export * from './state';
export * from './step';
export * from './yul';
