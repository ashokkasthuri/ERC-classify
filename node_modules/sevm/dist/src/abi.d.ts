/**
 * The following elementary types exist[1]:
 *
 * - `uint<M>`: unsigned integer type of M bits, 0 < M <= 256, M % 8 == 0. e.g. uint32, uint8, uint256.
 * - `int<M>: twoâ€™s complement signed integer type of M bits, 0 < M <= 256, M % 8 == 0.
 * - `address`: equivalent to uint160, except for the assumed interpretation and language typing. For computing the function selector, address is used.
 * - `uint`, `int`: synonyms for uint256, int256 respectively. For computing the function selector, uint256 and int256 have to be used.
 * - `bool`: equivalent to uint8 restricted to the values 0 and 1. For computing the function selector, bool is used.
 * - `fixed<M>x<N>`: signed fixed-point decimal number of M bits, 8 <= M <= 256, M % 8 == 0, and 0 < N <= 80, which denotes the value v as v / (10 ** N).
 * - `ufixed<M>x<N>`: unsigned variant of fixed<M>x<N>.
 * - `fixed`, `ufixed`: synonyms for fixed128x18, ufixed128x18 respectively. For computing the function selector, fixed128x18 and ufixed128x18 have to be used.
 * - `bytes<M>`: binary type of M bytes, 0 < M <= 32.
 * - `function`: an address (20 bytes) followed by a function selector (4 bytes). Encoded identical to bytes24.
 *
 * See also [2] for more information on Types.
 *
 * - [1] https://docs.soliditylang.org/en/latest/abi-spec.html#types
 * - [2] https://docs.soliditylang.org/en/latest/types.html
 */
export type Type = (typeof ELEM_TYPES)[number];
/**
 * Determine whether the given `type` is a valid elementary Solidity type.
 *
 * @see {@link Type} definition for more info on `Type`.
 *
 * @param type value to check if it is a valid elementary type.
 * @returns
 */
export declare function isElemType(type: string): type is Type;
/**
 *
 */
declare const ELEM_TYPES: readonly ["address", "address payable", "bool", "uint", ...("uint16" | "uint256" | "uint8" | "uint32" | "uint24" | "uint40" | "uint48" | "uint56" | "uint64" | "uint72" | "uint80" | "uint88" | "uint96" | "uint104" | "uint112" | "uint120" | "uint128" | "uint136" | "uint144" | "uint152" | "uint160" | "uint168" | "uint176" | "uint184" | "uint192" | "uint200" | "uint208" | "uint216" | "uint224" | "uint232" | "uint240" | "uint248" | "int" | "int16" | "int256" | "int8" | "int32" | "int24" | "int40" | "int48" | "int56" | "int64" | "int72" | "int80" | "int88" | "int96" | "int104" | "int112" | "int120" | "int128" | "int136" | "int144" | "int152" | "int160" | "int168" | "int176" | "int184" | "int192" | "int200" | "int208" | "int216" | "int224" | "int232" | "int240" | "int248" | "bytes" | "bytes2" | "bytes1" | "bytes16" | "bytes3" | "bytes8" | "bytes9" | "bytes11" | "bytes20" | "bytes21" | "bytes25" | "bytes26" | "bytes5" | "bytes32" | "bytes4" | "bytes6" | "bytes7" | "bytes10" | "bytes12" | "bytes13" | "bytes14" | "bytes15" | "bytes24" | "bytes17" | "bytes18" | "bytes19" | "bytes22" | "bytes23" | "bytes27" | "bytes28" | "bytes29" | "bytes30" | "bytes31")[], "string", "function"];
export type Ty = {
    type: string;
    components?: Ty[];
    arrayLength?: number | null;
    arrayType?: Ty;
};
export type SigMember = {
    name: string;
    inputs: ({
        name?: string;
    } & Ty)[];
};
export declare function parseSig(sig: string): SigMember;
/**
 *
 * https://docs.soliditylang.org/en/latest/abi-spec.html#handling-tuple-types
 *
 * @param member
 */
export declare function sighash(member: ReturnType<typeof parseSig>): string;
export declare function fnsig(member: ReturnType<typeof parseSig>): string;
export {};
